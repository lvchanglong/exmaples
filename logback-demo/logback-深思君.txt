你好，你认识深思君么？就是我...虽然我也认为，既然你都已经点了进来，那么一定是对logback有所了解的。但是呢，为了保险起见，还是容我来介绍一下logback吧，为了那些还不了解logback的同志，同时也为了你...或许你也能从中得到些收获也说不定呢！！！
那么，首先，第一个目的，知道logback是什么。logback，是一款基于java的开源日志框架。它由log4j的创始人设计并开发，是log4j的改良版本。与log4j相比，它拥有了更多的特性，同时在性能方面也有了大幅度的提升。
或许，从名称中也能看出一些端倪来，log back，有些王者归来的意味呢...
这里说到记录日志，你可能首先会想到java的System.out.println("Hello World")或者groovy的println "Hello World"，不得不说，这确实也是记录日志的一种形式，把日志信息输出到控制台上。
那么问题来了，为什么不用继续这两种方式而转用logback呢？那当然是，logback优点多啊，我只说其中最明显的一点，使用logback，你可以自由控制输出的内容。
什么日志要输出，什么日志不想输出，你都可以进行控制。就问你，这样会不会太爽？
好的，现在，logback是什么已经知道了，开源日志框架，是基于java的。开始下一个目的，宏观上理解logback，为了便于你的理解，我会在宏观上去介绍logback，微观上不会涉及也不必涉及，因为最重要的是知道怎么去用，而不是自己亲自去开发个logback伪
你需要知道，logback身上的几样宝...也就是重要组成部分啦！分别是root与logger、appender、encoder和layout。在接下的时间，会一一进行介绍，不要心急，慢慢来，慢慢来...
先来说说root，或者应该叫他root logger，因为root的本质就是一个logger。但却也不是一个一般的logger，他是特殊的，原因之一是所有的logger都继承自root。换句话说，root是所有logger的爸爸。
知道这一点后，再来看看，logback中的角色定位：
root和logger，主要负责日志信息的接收、过滤及以及委托appender进行输出的工作。
appender，宏观上讲，主要负责日志信息的输出（打印）工作。
encoder和layout，简单理解，主要负责日志信息在输出（打印）时，日志信息的格式化工作。

上文提到，logback有别于System.out.println("java")和println "groovy"的地方在于其“日志过滤”能力。接下来，我会说说，这“日志过滤”能力是如何实现的。
这就要从logback的创建开始说起，logback的创建立足于一条假设之上，那就是所有的日志信息都可以被分门别类。
日志信息是有等级之分的，简单理解，最低级为ALL，最高级为OFF，由低到高，依次是ALL（所有日志）, TRACE（相关日志）, DEBU（调试日志）, INFO（程序运行状态日志）, WARN（警告日志）, ERROR（错误日志）, OFF（关闭所有日志）。这里有一点值得注意，低级日志内容会涵盖高级日志内容，这也是你想要的，对吧。

我举个例子说明下吧，日志过滤的实现...我打算记录一条日志，日志信息为"Hello World"，由于其并不重要，因此我将其设定成了DEBUG等级。而后，我又设置了一个门限等级(level)，门限等级设置为INFO。那么，日志等级低于门限等级的日志都将被过滤掉，高于门限等级的日志才可通过，这我称之为“高通”。
此例中，由于日志"Hello World"的日志等级为DEBUG，而门限等级为INFO，"Hello World"将因等级不够而被拒之门外，禁止输出...

好的，目前为止，我猜你应该对logback有了一定程度的宏观了解了吧。那么下一讲，来学学logback的使用，下期见吧~


-----------------------------------------------------------


你好，你认识深思君么？就是我...如果看过上一期，想必你对logback，也已经有了一定程度的了解。那么本期，就来学学如何使用logback吧。首先是使用，为了便于理解，我不会使用logback之外的技术，例如maven...虽然我完全可以这么做...
既然是学习使用，那么肯定是要实现“Hello World”的。因为“Hello World”案例，是最简单、最基础、最适合入门的案例。而且输出一个“Hello World”字符串就大功告成啦...我...很省事...
那么，开始吧...百度搜索logback...下载解压...创建项目...引入必要jar包...敲入代码...执行...成功
第一步已经完成。第二步，查看logback实时运行状态，知己知彼，百战不殆嘛...敲代码中...执行...成功
可以看到，logback正在寻找配置文件，先找logback-test.xml，没有则找logback.groovy，还没有则找logback.xml。都没有就使用logback的默认配置。
既然说到默认配置，就来简单讲解一下吧。主要有两点值得注意下：第一点，默认的日志输出方式是“输出（打印）在控制台上”，具体来说，使用的appender是ConsoleAppender；第二点，默认的日志“门限等级”是DEBUG，只有高于DEBUG等级的日志才会输出到控制台上。
这就来测试一下吧...我的说法...看看准确与否...没毛病

下一步，使用自定义的logback配置文件。为了节省时间，我将导入已经写好的logback配置文件来进行说明，用的是xml格式，即logback.xml。顺便说一句，logback.groovy和logback.xml的语法是不同的，logback.groovy这个我将在留到之后去讲...最后，强推logback.groovy!!!
...将logback.xml放到resources下...执行...已找到logback.xml...完美
那么，下一期，开始学习如何自定义配置文件吧。哦，还得再强调一句，配置文件的作用只是“配置执行策略”，而真正按照策略执行的执行者是logback，这样会更好理解...那么，下期见，自定义“执行策略”...


----------------------------------------------------------------------------------


你好，你认识深思君么？就是我...如果你看过上一期，想必就已经能够简单使用logback了。本期，你将学到，如何自定义logback配置文件。容我再次强调一下，配置文件的作用只是“配置执行策略”，真正按照策略执行的执行者是logback，请你这样去想...那么开始吧，自定义“执行策略”...
字幕菌罢工中！！！
屏蔽...debug改成true...执行一下...
字幕菌继续罢工中！！！
本期就讲到这里吧...下期讲logback.groovy的配置，这是强推的哦！！！


----------------------------------------------------------------------------------


你好，你认识深思君么？就是我...如果你看过上一期，想必就已经能够配置logback了。本期介绍另一种配置方式，本人强烈推荐的logback.groovy方式。
字幕菌罢工中！！！
好，大功告成...运行...报错...因为需要添加groovy依赖...还是用一下maven吧，也能让你多学点东西不是...
百度搜索maven repository...搜groovy...点maven...复制...粘贴到pom.xml中的dependencies中...耐心等待...
执行...成功...本期就到这里...下期，带你去看看，Grails框架中，logback的样子，下期见！！！


--------------------------------------------------


你好，你认识深思君么？就是我...如果你看过上一期，想必就已经能够用groovy的方式来配置logback了（logback.groovy）。本期我将带你去瞅瞅，Grails框架中logback的样子。
不难发现，groovy文件中是可以写groovy代码的...好像是废话...不管如何，println什么的都可以写的哦...
还有一个特殊的名字，StackTrace，中文名是“堆栈跟踪”。那么，堆栈跟踪是什么？简单理解，当程序运行中出错并且抛出异常时，与异常相关的一系列函数调用的轨迹就会被显示出来，这一系列的函数调用轨迹就被称为“堆栈跟踪”。
最后，简单演示一下，在Grails中logback的使用：
log.debug("debug等级")
log.info("info等级")
log.error("error等级")
没有任何一个包名或者类名叫StackTrace，换句话说，StackTrace是特殊的，是未经过滤的堆栈跟踪，简单理解，StackTrace logger是给框架记录错误日志用的。
故意报个错...1/0...这些错误就可以理解为堆栈跟踪...
本期就到这里！完结！撒花！可喜可贺！可喜可贺！！！